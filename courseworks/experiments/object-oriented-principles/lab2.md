# سیستم پردازش آنلاین پرداخت

## بررسی کلی
دانشجویان به صورت تیمی (دو نفره) یک سیستم پردازش آنلاین پرداخت طراحی و پیاده‌سازی می‌کنند که باید مدولار، مقیاس‌پذیر و دارای مستندات کامل باشد. این آزمایش در چندین مرحله تقسیم‌بندی شده است که هر کدام شامل وظایف کدنویسی، نقطه‌های کنترل برای کامیت کردن تغییرات و مستندسازی بازتابی می‌باشد:

- مرحله ۱: تحلیل و شناسایی Code Smell  
- مرحله ۲: بازآرایی برای کپسوله‌سازی و انتزاع  
- مرحله ۳: معرفی وراثت و چندریختی از طریق رابط PaymentGateway  
- مرحله ۴: بازآرایی پیشرفته و یکپارچه‌سازی (تزریق وابستگی و مدیریت پیکربندی)  
- مرحله ۵: تست، مستندسازی و بازبینی توسط همتایان  
- مرحله ۶: بازتاب و ارسال نهایی

هر مرحله شامل وظایف مشخص، نقاط کنترل کامیت و گام‌های مستندسازی برای اطمینان از یادگیری مستمر و همکاری تیمی می‌باشد.


## مرحله ۱: تحلیل اولیه و شناسایی Code Smell

هدف:  
تحلیل کد payment یکپارچه (به عنوان کد اولیه ارائه شده) جهت شناسایی اشکالات طراحی و نقض اصول SOLID.

وظایف:
- بررسی کد:  
  - مطالعه کد یکپارچه‌ای که شامل اعتبارسنجی پرداخت، پردازش پرداخت و یکپارچه‌سازی با درگاه‌های خارجی است.
  - شناسایی مسائلی مانند وابستگی بیش از حد، متدهای طولانی، تکرار کد و مسئولیت‌های نامشخص.
- مستندسازی:  
  - تهیه گزارشی (یا افزودن توضیحات درون کد) که Code Smell‌های شناسایی شده را فهرست کند.
  - ذکر اصول SOLID نقض شده (مثلاً اصل مسئولیت واحد، اصل باز/بسته و غیره).
- نقطه کنترل:  
  - کامیت کردن یافته‌ها و گزارش خلاصه در شاخه‌ای به نام `stage1-analysis` با پیغام کامیت مانند “Stage 1: Documented code smells and SOLID violations.”

همکاری تیمی:  
- تقسیم کار: یکی از اعضا کد را مطالعه می‌کند در حالی که دیگری یک چک‌لیست برای اصول SOLID تهیه می‌کند.
- استفاده از یک سند مشترک (مثلاً به‌روزرسانی README.md یا فایل تحلیل جداگانه) برای ثبت یافته‌ها.


## مرحله ۲: بازآرایی برای کپسوله‌سازی و انتزاع

هدف:  
بازآرایی ماژول یکپارچه با معرفی کلاس انتزاعی `Payment` و ایجاد زیرکلاس‌های مشخص برای هر نوع پرداخت (مانند `CreditCardPayment`، `DigitalWalletPayment`، `BankTransferPayment`).

وظایف:
- طراحی و کدنویسی:  
  - ایجاد کلاس انتزاعی `Payment` با ویژگی‌های مشترک (مانند مبلغ، ارز، زمان ثبت) و متدی به نام `validatePayment()`.
  - توسعه زیرکلاس‌هایی که متد `validatePayment()` را بازنویسی یا گسترش می‌دهند و رفتارهای خاص مربوط به خود را اضافه می‌کنند.
  - جداسازی منطق پردازش پرداخت از یکپارچه‌سازی با API‌های شخص ثالث.
- مستندسازی:  
  - افزودن توضیحات درون کد و تولید مستندات اولیه (مثلاً Javadoc یا Doxygen) برای کلاس‌های جدید.
  - به‌روزرسانی مستندات پروژه (مانند README.md) برای نمایش معماری جدید.
- نقطه کنترل:  
  - کامیت کردن تغییرات در شاخه‌ای به نام `stage2-refactor` با پیغام‌های کامیت واضح (مثلاً “Stage 2: Added Payment abstraction and concrete subclasses”).

همکاری تیمی:  
- تقسیم وظایف: یکی از اعضا طراحی کلاس انتزاعی را بر عهده می‌گیرد و دیگری پیاده‌سازی انواع پرداخت را انجام می‌دهد.
- استفاده از pull request در GitHub جهت بازبینی متقابل کامیت‌ها.


## مرحله ۳: وراثت و چندریختی با رابط PaymentGateway

هدف:  
طراحی و پیاده‌سازی یک رابط `PaymentGateway` برای جداسازی یکپارچه‌سازی درگاه‌های پرداخت از منطق اصلی پرداخت.

وظایف:
- طراحی رابط:  
  - تعریف رابط `PaymentGateway` با متدهایی مانند `processPayment()`، `refundPayment()` و `getTransactionStatus()`.
- پیاده‌سازی درگاه‌های مشخص:  
  - ایجاد حداقل دو کلاس (مثلاً `StripeGateway` و `PayPalGateway`) که این رابط را پیاده‌سازی می‌کنند.
  - در صورت امکان، استفاده از وراثت برای به اشتراک گذاشتن منطق مشترک (مثلاً ایجاد یک کلاس پایه به نام `BaseGateway`).
- چندریختی:  
  - تغییر سیستم پردازش پرداخت به گونه‌ای که بتواند هر پیاده‌سازی از رابط `PaymentGateway` را بپذیرد.
  - نشان دادن عملکرد چندریختی با تغییر درگاه‌ها در زمان اجرا.
- مستندسازی:  
  - مستندسازی رابط و پیاده‌سازی‌های آن با توضیحات درون کد و در صورت تمایل، نمودارهای طراحی.
- نقطه کنترل:  
  - کامیت کردن تغییرات در شاخه‌ای به نام `stage3-gateway` با پیغام‌هایی مانند “Stage 3: Introduced PaymentGateway interface and concrete implementations.”

همکاری تیمی:  
- تقسیم کار: یکی از اعضا طراحی و مستندسازی رابط را انجام می‌دهد در حالی که دیگری پیاده‌سازی کلاس‌های درگاه را بر عهده دارد.
- استفاده از جلسات pair programming برای تست عملکرد چندریختی به صورت مشترک.


## مرحله ۴: یکپارچه‌سازی و بازآرایی پیشرفته

هدف:  
جداسازی وابستگی‌های خارجی و بهبود مدیریت پیکربندی با استفاده از بازآرایی پیشرفته و تزریق وابستگی.

وظایف:
- تزریق وابستگی:  
  - بازآرایی سیستم به گونه‌ای که درگاه‌های پرداخت خارجی به جای اینکه به صورت hard-coded تعریف شوند، از طریق تزریق وارد شوند.
  - ایجاد یک مدیر پیکربندی برای بارگذاری جزئیات حساس (مانند کلید‌های API و URL‌های پایانی) از فایل‌های امن یا متغیرهای محیطی.
- ایزوله‌سازی کد:  
  - جداسازی منطق‌ها: جدا کردن پردازش پرداخت، یکپارچه‌سازی درگاه‌ها و مدیریت پیکربندی به ماژول‌های مجزا.
  - به‌روزرسانی طراحی جهت استفاده از رابط‌های تعریف‌شده میان ماژول‌ها.
- مستندسازی:  
  - به‌روزرسانی مستندات طراحی و توضیحات درون کد برای توضیح نحوه پیاده‌سازی تزریق وابستگی و مدیریت پیکربندی خارجی.
- نقطه کنترل:  
  - کامیت کردن تغییرات در شاخه‌ای به نام `stage4-integration` با پیغام کامیت مانند “Stage 4: Applied dependency injection and externalized configuration.”

همکاری تیمی:  
- همکاری مشترک در انتخاب یک چارچوب DI یا پیاده‌سازی یک container ساده برای تزریق وابستگی.
- استفاده از Issues و PR‌های GitHub برای اطمینان از عدم نشت داده‌های حساس.


## مرحله ۵: تست، مستندسازی و بازبینی نهایی

هدف:  
اطمینان از عملکرد صحیح سیستم از طریق تست‌های جامع و ایجاد مستندات کامل.

وظایف:
- توسعه تست‌ها:  
  - نوشتن تست‌های واحد (Unit Test) برای هر کلاس (به ویژه برای زیرکلاس‌های `Payment` و پیاده‌سازی‌های `PaymentGateway`).
  - توسعه تست‌های یکپارچه (Integration Test) برای شبیه‌سازی سناریوهایی مانند شکست در پرداخت، زمان‌بندی شبکه، عملیات بازپرداخت و غیره.
- مستندسازی:  
  - تولید مستندات کامل (با استفاده از Javadoc/Doxygen) و به‌روزرسانی README پروژه جهت توضیح معماری سیستم، تصمیمات طراحی و استراتژی‌های تست.
  - ثبت تاریخچه کامیت‌های Git و ایجاد فایل “CHANGELOG” جهت خلاصه تغییرات عمده در مراحل مختلف.
- بازبینی توسط همتایان:  
  - برگزاری جلسه بازبینی کد با همکاری تیمی جهت اطمینان از رعایت اصول شیءگرایی و SOLID پس از بازآرایی.
  - تهیه گزارشی (به صورت فایل Markdown جداگانه) که بهبودها و پیشنهادات بیشتر را ثبت می‌کند.
- نقطه کنترل:  
  - کامیت کردن تست‌ها و بهبودهای مستندسازی در شاخه‌ای به نام `stage5-testing-docs`.

همکاری تیمی:  
- تقسیم وظایف تست: یکی روی تست‌های واحد تمرکز کند و دیگری بر روی تست‌های یکپارچه.
- استفاده از قابلیت بازبینی PR در GitHub جهت ارائه بازخورد سازنده.


## مرحله ۶: بازتاب و ارسال نهایی

هدف:  
بازتاب بر فرآیند بازآرایی، چالش‌های موجود و درس‌های آموخته شده و آماده‌سازی ارسال نهایی پروژه.

وظایف:
- گزارش بازتاب:  
  - تهیه گزارشی نهایی که شامل موارد زیر باشد:
    - چالش‌های اصلی در طول فرآیند بازآرایی.
    - چگونگی کاهش پیچیدگی با استفاده از انتزاع، کپسوله‌سازی، وراثت و چندریختی.
    - مزایای معرفی رابط‌ها برای قابلیت تست و مدولار بودن سیستم.
    - اثربخشی استراتژی‌های تست و پیشنهادات برای بهبود‌های آینده.
  - درج بازتاب‌های مربوط به همکاری تیمی و استفاده از GitHub (مانند استراتژی شاخه‌ها، بازبینی کد و غیره).
- سازماندهی نهایی مخزن:  
  - اطمینان از قرارگیری کد منبع، تست‌ها، مستندات و گزارش بازتاب در پوشه‌های جداگانه در مخزن GitHub.
  - ادغام تمامی شاخه‌ها به شاخه `main`.
  - در صورت نیاز، اصلاح پیام‌های کامیت جهت وضوح بیشتر.
- دستورالعمل ارسال:  
  - push کردن تمامی تغییرات و ارائه لینک نهایی مخزن.
  - به‌روزرسانی README.md شامل:
    - مرور کلی پروژه و معماری آن
    - توضیح گام به گام تغییرات هر مرحله
    - دستورالعمل‌های اجرای تست‌ها و ساخت پروژه
    - خلاصه‌ای از گزارش بازتاب
- نقطه کنترل:  
  - کامیت نهایی در شاخه `main` با پیغام مانند “Final Submission: Completed all stages, documentation, and reflection.”

همکاری تیمی:  
- بحث و تبادل نظر درباره درس‌های آموخته شده در تیم و ثبت مشارکت‌های هر عضو.
- استفاده از سند مشترک (یا فایل Markdown) جهت تهیه گزارش بازتاب و کامیت آن به مخزن.


# راهنمایی‌ها و بهترین شیوه‌ها

- مدیریت زمان:  
  - کار به صورت iterative انجام شود تا هر مرحله بر اساس مرحله قبل ساخته شود.
  - کامیت کردن به‌طور منظم با پیام‌های توصیفی.
- یکپارچه‌سازی Git/GitHub:  
  - استفاده از شاخه‌های ویژگی (feature branches) برای هر مرحله (مثلاً `stage1-analysis`، `stage2-refactor` و غیره).
  - برگزاری جلسات بازبینی کد به صورت pull request.
  - حل تعارض‌های merge به‌صورت تیمی.
- مستندسازی و بازتاب:  
  - نگهداری لاگ یا دفترچه یادداشت پروژه جهت ثبت تصمیمات، چالش‌ها و درس‌های آموخته شده در پایان هر مرحله.
  - استفاده از توضیحات درون کد و مستندات خارجی برای حمایت از تصمیمات طراحی.
- همکاری و بازبینی توسط همتایان:  
  - برنامه‌ریزی جلسات کوتاه پس از پایان هر مرحله جهت مقایسه تغییرات، بحث در خصوص چالش‌ها و برنامه‌ریزی مراحل بعدی.
  - هر عضو باید کد عضو دیگر را بازبینی کند و بازخورد سازنده ارائه دهد.
- ارسال نهایی:  
  - سازماندهی مخزن به گونه‌ای که برای استاد به راحتی قابل مرور باشد.
  - ارائه یک README نهایی شامل بخش‌هایی درباره مرور کلی پروژه، فرآیند توسعه و بازتاب.
  - ارسال لینک مخزن GitHub طبق دستورالعمل استاد.