# سیستم پردازش آنلاین پرداخت

## بررسی کلی
دانشجویان به صورت تیمی (دو نفره) یک سیستم پردازش آنلاین پرداخت طراحی و پیاده‌سازی می‌کنند که باید مدولار، مقیاس‌پذیر و دارای مستندات کامل باشد. این آزمایش در چندین مرحله تقسیم‌بندی شده است که هر کدام شامل وظایف کدنویسی، نقطه‌های کنترل برای کامیت کردن تغییرات و مستندسازی بازتابی می‌باشد:

- مرحله ۱: تحلیل و شناسایی Code Smell  
- مرحله ۲: بازآرایی برای کپسوله‌سازی و انتزاع  
- مرحله ۳: معرفی وراثت و چندریختی از طریق رابط PaymentGateway  
- مرحله ۴: بازآرایی پیشرفته و یکپارچه‌سازی (dependency injection و مدیریت پیکربندی)  

هر مرحله شامل وظایف مشخص، نقاط کنترل کامیت و گام‌های مستندسازی برای اطمینان از یادگیری مستمر و همکاری تیمی می‌باشد.


## مرحله ۱: تحلیل اولیه و شناسایی Code Smell

هدف:  
تحلیل کد payment یکپارچه ([که به عنوان کد اولیه ارائه شده](./PaymentProcessor.java)) جهت شناسایی اشکالات طراحی و نقض اصول SOLID.

وظایف:
- بررسی کد:  
  - مطالعه کد یکپارچه‌ای که شامل اعتبارسنجی پرداخت، پردازش پرداخت و یکپارچه‌سازی با درگاه‌های خارجی است.
  - شناسایی مسائلی مانند وابستگی بیش از حد، متدهای طولانی، تکرار کد و مسئولیت‌های نامشخص.
- مستندسازی:  
  - تهیه گزارشی (یا افزودن توضیحات درون کد) که Code Smell‌های شناسایی شده را فهرست کند.
  - ذکر اصول SOLID نقض شده (مثلاً اصل مسئولیت واحد، اصل باز/بسته و غیره).
- نقطه کنترل:  
  - کامیت کردن یافته‌ها و گزارش خلاصه در شاخه‌ای به نام `stage1-analysis` با پیغام کامیت مانند “Stage 1: Documented code smells and SOLID violations.”

همکاری تیمی:  
- تقسیم کار: یکی از اعضا کد را مطالعه می‌کند در حالی که دیگری یک چک‌لیست برای اصول SOLID تهیه می‌کند.
- استفاده از یک سند مشترک (مثلاً به‌روزرسانی README.md یا فایل تحلیل جداگانه) برای ثبت یافته‌ها.


## مرحله ۲: بازآرایی برای کپسوله‌سازی و انتزاع

هدف:  
بازآرایی ماژول یکپارچه با معرفی کلاس انتزاعی `Payment` و ایجاد زیرکلاس‌های مشخص برای هر نوع پرداخت (مانند `CreditCardPayment`، `DigitalWalletPayment`، `BankTransferPayment`).

وظایف:
- طراحی و کدنویسی:  
  - ایجاد کلاس انتزاعی `Payment` با ویژگی‌های مشترک (مانند مبلغ، ارز، زمان ثبت) و متدی به نام `validatePayment()`.
  - توسعه زیرکلاس‌هایی که متد `validatePayment()` را بازنویسی یا گسترش می‌دهند و رفتارهای خاص مربوط به خود را اضافه می‌کنند.
  - جداسازی منطق پردازش پرداخت از یکپارچه‌سازی با API‌های شخص ثالث.
- مستندسازی:  
  - افزودن توضیحات درون کد و تولید مستندات اولیه (مثلاً Javadoc یا Doxygen) برای کلاس‌های جدید.
  - به‌روزرسانی مستندات پروژه (مانند README.md) برای نمایش معماری جدید.
- نقطه کنترل:  
  - کامیت کردن تغییرات در شاخه‌ای به نام `stage2-refactor` با پیغام‌های کامیت واضح (مثلاً “Stage 2: Added Payment abstraction and concrete subclasses”).

همکاری تیمی:  
- تقسیم وظایف: یکی از اعضا طراحی کلاس انتزاعی را بر عهده می‌گیرد و دیگری پیاده‌سازی انواع پرداخت را انجام می‌دهد.
- استفاده از pull request در GitHub جهت بازبینی متقابل کامیت‌ها.


## مرحله ۳: وراثت و چندریختی با رابط PaymentGateway

هدف:  
طراحی و پیاده‌سازی یک رابط `PaymentGateway` برای جداسازی یکپارچه‌سازی درگاه‌های پرداخت از منطق اصلی پرداخت.

وظایف:
- طراحی رابط:  
  - تعریف رابط `PaymentGateway` با متدهایی مانند `processPayment()`، `refundPayment()` و `getTransactionStatus()`.
- پیاده‌سازی درگاه‌های مشخص:  
  - ایجاد حداقل دو کلاس (مثلاً `StripeGateway` و `PayPalGateway`) که این رابط را پیاده‌سازی می‌کنند.
  - در صورت امکان، استفاده از وراثت برای به اشتراک گذاشتن منطق مشترک (مثلاً ایجاد یک کلاس پایه به نام `BaseGateway`).
- چندریختی:  
  - تغییر سیستم پردازش پرداخت به گونه‌ای که بتواند هر پیاده‌سازی از رابط `PaymentGateway` را بپذیرد.
  - نشان دادن عملکرد چندریختی با تغییر درگاه‌ها در زمان اجرا.
- مستندسازی:  
  - مستندسازی رابط و پیاده‌سازی‌های آن با توضیحات درون کد و در صورت تمایل، نمودارهای طراحی.
- نقطه کنترل:  
  - کامیت کردن تغییرات در شاخه‌ای به نام `stage3-gateway` با پیغام‌هایی مانند “Stage 3: Introduced PaymentGateway interface and concrete implementations.”

همکاری تیمی:  
- تقسیم کار: یکی از اعضا طراحی و مستندسازی رابط را انجام می‌دهد در حالی که دیگری پیاده‌سازی کلاس‌های درگاه را بر عهده دارد.
- استفاده از جلسات pair programming برای تست عملکرد چندریختی به صورت مشترک.


## مرحله ۴: یکپارچه‌سازی و بازآرایی پیشرفته

هدف:  
جداسازی وابستگی‌های خارجی و بهبود مدیریت پیکربندی با استفاده از بازآرایی پیشرفته و dependency injection.

وظایف:
- dependency injection:  
  - بازآرایی سیستم به گونه‌ای که درگاه‌های پرداخت خارجی به جای اینکه به صورت hard-coded تعریف شوند، از طریق تزریق وارد شوند.
  - ایجاد یک مدیر پیکربندی برای بارگذاری جزئیات حساس (مانند کلید‌های API و URL‌های پایانی) از فایل‌های امن یا متغیرهای محیطی.
- ایزوله‌سازی کد:  
  - جداسازی منطق‌ها: جدا کردن پردازش پرداخت، یکپارچه‌سازی درگاه‌ها و مدیریت پیکربندی به ماژول‌های مجزا.
  - به‌روزرسانی طراحی جهت استفاده از رابط‌های تعریف‌شده میان ماژول‌ها.
- مستندسازی:  
  - به‌روزرسانی مستندات طراحی و توضیحات درون کد برای توضیح نحوه پیاده‌سازی dependency injection و مدیریت پیکربندی خارجی.
- نقطه کنترل:  
  - کامیت کردن تغییرات در شاخه‌ای به نام `stage4-integration` با پیغام کامیت مانند “Stage 4: Applied dependency injection and externalized configuration.”

همکاری تیمی:  
- همکاری مشترک در انتخاب یک چارچوب DI یا پیاده‌سازی یک container ساده برای dependency injection.
- استفاده از Issues و PR‌های GitHub برای اطمینان از عدم نشت داده‌های حساس.


# راهنمایی‌ها و بهترین شیوه‌ها

- مدیریت زمان:  
  - کار به صورت iterative انجام شود تا هر مرحله بر اساس مرحله قبل ساخته شود.
  - کامیت کردن به‌طور منظم با پیام‌های توصیفی.
- یکپارچه‌سازی Git/GitHub:  
  - استفاده از شاخه‌های ویژگی (feature branches) برای هر مرحله (مثلاً `stage1-analysis`، `stage2-refactor` و غیره).
  - برگزاری جلسات بازبینی کد به صورت pull request.
  - حل تعارض‌های merge به‌صورت تیمی.
- مستندسازی و بازتاب:  
  - نگهداری لاگ یا دفترچه یادداشت پروژه جهت ثبت تصمیمات، چالش‌ها و درس‌های آموخته شده در پایان هر مرحله.
  - استفاده از توضیحات درون کد و مستندات خارجی برای حمایت از تصمیمات طراحی.
- همکاری و بازبینی توسط همتایان:  
  - برنامه‌ریزی جلسات کوتاه پس از پایان هر مرحله جهت مقایسه تغییرات، بحث در خصوص چالش‌ها و برنامه‌ریزی مراحل بعدی.
  - هر عضو باید کد عضو دیگر را بازبینی کند و بازخورد سازنده ارائه دهد.
- ارسال نهایی:  
  - سازماندهی مخزن به گونه‌ای که برای استاد به راحتی قابل مرور باشد.
  - ارائه یک README نهایی شامل بخش‌هایی درباره مرور کلی پروژه، فرآیند توسعه و بازتاب.
  - ارسال لینک مخزن GitHub طبق دستورالعمل استاد.